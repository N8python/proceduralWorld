/*! For license information please see enable3d.ammoPhysics.0.22.0-dev.1.min.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE"),require("ConvexGeometry")):"function"==typeof define&&define.amd?define(["THREE","ConvexGeometry"],e):"object"==typeof exports?exports.ENABLE3D=e(require("THREE"),require("ConvexGeometry")):t.ENABLE3D=e(t.THREE,t.ConvexGeometry)}(self,(function(t,e){return(()=>{"use strict";var s={161:t=>{var e=Object.prototype.hasOwnProperty,s="~";function o(){}function i(t,e,s){this.fn=t,this.context=e,this.once=s||!1}function r(t,e,o,r,n){if("function"!=typeof o)throw new TypeError("The listener must be a function");var a=new i(o,r||t,n),l=s?s+e:e;return t._events[l]?t._events[l].fn?t._events[l]=[t._events[l],a]:t._events[l].push(a):(t._events[l]=a,t._eventsCount++),t}function n(t,e){0==--t._eventsCount?t._events=new o:delete t._events[e]}function a(){this._events=new o,this._eventsCount=0}Object.create&&(o.prototype=Object.create(null),(new o).__proto__||(s=!1)),a.prototype.eventNames=function(){var t,o,i=[];if(0===this._eventsCount)return i;for(o in t=this._events)e.call(t,o)&&i.push(s?o.slice(1):o);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(t)):i},a.prototype.listeners=function(t){var e=s?s+t:t,o=this._events[e];if(!o)return[];if(o.fn)return[o.fn];for(var i=0,r=o.length,n=new Array(r);i<r;i++)n[i]=o[i].fn;return n},a.prototype.listenerCount=function(t){var e=s?s+t:t,o=this._events[e];return o?o.fn?1:o.length:0},a.prototype.emit=function(t,e,o,i,r,n){var a=s?s+t:t;if(!this._events[a])return!1;var l,m,c=this._events[a],h=arguments.length;if(c.fn){switch(c.once&&this.removeListener(t,c.fn,void 0,!0),h){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,e),!0;case 3:return c.fn.call(c.context,e,o),!0;case 4:return c.fn.call(c.context,e,o,i),!0;case 5:return c.fn.call(c.context,e,o,i,r),!0;case 6:return c.fn.call(c.context,e,o,i,r,n),!0}for(m=1,l=new Array(h-1);m<h;m++)l[m-1]=arguments[m];c.fn.apply(c.context,l)}else{var d,u=c.length;for(m=0;m<u;m++)switch(c[m].once&&this.removeListener(t,c[m].fn,void 0,!0),h){case 1:c[m].fn.call(c[m].context);break;case 2:c[m].fn.call(c[m].context,e);break;case 3:c[m].fn.call(c[m].context,e,o);break;case 4:c[m].fn.call(c[m].context,e,o,i);break;default:if(!l)for(d=1,l=new Array(h-1);d<h;d++)l[d-1]=arguments[d];c[m].fn.apply(c[m].context,l)}}return!0},a.prototype.on=function(t,e,s){return r(this,t,e,s,!1)},a.prototype.once=function(t,e,s){return r(this,t,e,s,!0)},a.prototype.removeListener=function(t,e,o,i){var r=s?s+t:t;if(!this._events[r])return this;if(!e)return n(this,r),this;var a=this._events[r];if(a.fn)a.fn!==e||i&&!a.once||o&&a.context!==o||n(this,r);else{for(var l=0,m=[],c=a.length;l<c;l++)(a[l].fn!==e||i&&!a[l].once||o&&a[l].context!==o)&&m.push(a[l]);m.length?this._events[r]=1===m.length?m[0]:m:n(this,r)}return this},a.prototype.removeAllListeners=function(t){var e;return t?(e=s?s+t:t,this._events[e]&&n(this,e)):(this._events=new o,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=s,a.EventEmitter=a,t.exports=a},729:t=>{var e=Object.prototype.hasOwnProperty,s="~";function o(){}function i(t,e,s){this.fn=t,this.context=e,this.once=s||!1}function r(t,e,o,r,n){if("function"!=typeof o)throw new TypeError("The listener must be a function");var a=new i(o,r||t,n),l=s?s+e:e;return t._events[l]?t._events[l].fn?t._events[l]=[t._events[l],a]:t._events[l].push(a):(t._events[l]=a,t._eventsCount++),t}function n(t,e){0==--t._eventsCount?t._events=new o:delete t._events[e]}function a(){this._events=new o,this._eventsCount=0}Object.create&&(o.prototype=Object.create(null),(new o).__proto__||(s=!1)),a.prototype.eventNames=function(){var t,o,i=[];if(0===this._eventsCount)return i;for(o in t=this._events)e.call(t,o)&&i.push(s?o.slice(1):o);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(t)):i},a.prototype.listeners=function(t){var e=s?s+t:t,o=this._events[e];if(!o)return[];if(o.fn)return[o.fn];for(var i=0,r=o.length,n=new Array(r);i<r;i++)n[i]=o[i].fn;return n},a.prototype.listenerCount=function(t){var e=s?s+t:t,o=this._events[e];return o?o.fn?1:o.length:0},a.prototype.emit=function(t,e,o,i,r,n){var a=s?s+t:t;if(!this._events[a])return!1;var l,m,c=this._events[a],h=arguments.length;if(c.fn){switch(c.once&&this.removeListener(t,c.fn,void 0,!0),h){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,e),!0;case 3:return c.fn.call(c.context,e,o),!0;case 4:return c.fn.call(c.context,e,o,i),!0;case 5:return c.fn.call(c.context,e,o,i,r),!0;case 6:return c.fn.call(c.context,e,o,i,r,n),!0}for(m=1,l=new Array(h-1);m<h;m++)l[m-1]=arguments[m];c.fn.apply(c.context,l)}else{var d,u=c.length;for(m=0;m<u;m++)switch(c[m].once&&this.removeListener(t,c[m].fn,void 0,!0),h){case 1:c[m].fn.call(c[m].context);break;case 2:c[m].fn.call(c[m].context,e);break;case 3:c[m].fn.call(c[m].context,e,o);break;case 4:c[m].fn.call(c[m].context,e,o,i);break;default:if(!l)for(d=1,l=new Array(h-1);d<h;d++)l[d-1]=arguments[d];c[m].fn.apply(c[m].context,l)}}return!0},a.prototype.on=function(t,e,s){return r(this,t,e,s,!1)},a.prototype.once=function(t,e,s){return r(this,t,e,s,!0)},a.prototype.removeListener=function(t,e,o,i){var r=s?s+t:t;if(!this._events[r])return this;if(!e)return n(this,r),this;var a=this._events[r];if(a.fn)a.fn!==e||i&&!a.once||o&&a.context!==o||n(this,r);else{for(var l=0,m=[],c=a.length;l<c;l++)(a[l].fn!==e||i&&!a[l].once||o&&a[l].context!==o)&&m.push(a[l]);m.length?this._events[r]=1===m.length?m[0]:m:n(this,r)}return this},a.prototype.removeAllListeners=function(t){var e;return t?(e=s?s+t:t,this._events[e]&&n(this,e)):(this._events=new o,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=s,a.EventEmitter=a,t.exports=a},152:t=>{t.exports=e},428:e=>{e.exports=t}},o={};function i(t){if(o[t])return o[t].exports;var e=o[t]={exports:{}};return s[t](e,e.exports,i),e.exports}i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{i.r(r),i.d(r,{AllHitsRaycaster:()=>L,AmmoPhysics:()=>W,Clock:()=>R,ClosestRaycaster:()=>j,ExtendedGroup:()=>l,ExtendedMesh:()=>a,ExtendedObject3D:()=>n,PhysicsLoader:()=>E,Types:()=>t});var t={};i.r(t);const e=t=>{console.error(`%c [enable3d] ${t} `,"background: #222; color: #bada55")};var s=i(161),o=i(428);class n extends o.Object3D{constructor(){super(),this.vector3=new o.Vector3,this.isGroup=!1,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.anims={},this._currentAnimation="",this._animationActions=new Map,this.name=`object-${this.id}`}setAction(t){console.warn("[enable3d] setAction(name) is deprecated. Use animation.play(name) instead!"),this.animationPlay(t)}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}get animation(){return{current:this._currentAnimation,add:(t,e)=>this.animationAdd(t,e),play:(t,e=500,s=!0)=>this.animationPlay(t,e,s),mixer:this.animationMixer}}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new o.AnimationMixer(this)),this._animationMixer}animationAdd(t,e){this._animationActions.set(t,this.animationMixer.clipAction(e))}animationPlay(t,e=500,s=!0){const i=this._animationActions.get(t),r=this._animationActions.get(this._currentAnimation);i&&(i.reset(),r&&(i.crossFadeFrom(r,e/1e3,!0),i.clampWhenFinished=!0),s||i.setLoop(o.LoopOnce,0),i.play()),this._currentAnimation=t}}class a extends o.Mesh{constructor(t,e){super(t,e),this.vector3=new o.Vector3,this.isGroup=!1,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}class l extends o.Group{constructor(){super(),this.isMesh=!1,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}}class m{constructor(t,e){this.worldTransform=t,this.physicsWorld=e,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,e=0){return new Ammo.btVector3(void 0!==(null==t?void 0:t.x)?t.x:e,void 0!==(null==t?void 0:t.y)?t.y:e,void 0!==(null==t?void 0:t.z)?t.z:e)}get addConstraints(){return{lock:(t,e,s)=>this.lock(t,e,s),fixed:(t,e,s)=>this.fixed(t,e,s),pointToPoint:(t,e,s,o)=>this.pointToPoint(t,e,s,o),hinge:(t,e,s,o)=>this.hinge(t,e,s,o),slider:(t,e,s={},o)=>this.slider(t,e,s,o),spring:(t,e,s={},o)=>this.spring(t,e,s,o),coneTwist:(t,e,s={frameA:{},frameB:{}},o)=>this.coneTwist(t,e,s,o),dof:(t,e,s,o)=>this.dof(t,e,s,o)}}getTransform(t,e,s={x:0,y:0,z:0},o=!1){s=Object.assign({x:0,y:0,z:0},s);const i=new Ammo.btTransform;if(i.setIdentity(),o){const o=(r=t.getWorldTransform().getOrigin(),n=e.getWorldTransform().getOrigin(),a=(r.x()-n.x())/2+s.x,l=(r.y()-n.y())/2+s.y,m=(r.z()-n.z())/2+s.z,new Ammo.btVector3(a,l,m)),i=new Ammo.btTransform;i.setIdentity(),i.setOrigin(o);const c=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return c.op_mul(i),{transformA:c,transformB:i}}return i.setOrigin(new Ammo.btVector3(s.x,s.y,s.z)),{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(i),transformB:i};var r,n,a,l,m}lock(t,e,s=!0){const o={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:o,angularUpperLimit:o},s)}fixed(t,e,s=!0){const o=this.getTransform(t.ammo,e.ammo);o.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),o.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const i=new Ammo.btFixedConstraint(t.ammo,e.ammo,o.transformA,o.transformB);return this.physicsWorld.addConstraint(i,s),i}pointToPoint(t,e,s={},o=!0){const{pivotA:i,pivotB:r}=s,n=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),a=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),l=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,n,a);return this.physicsWorld.addConstraint(l,o),l}hinge(t,e,s={},o=!0){const{pivotA:i,pivotB:r,axisA:n,axisB:a}=s,l=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),m=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),c=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),h=new Ammo.btVector3((null==a?void 0:a.x)||0,(null==a?void 0:a.y)||0,(null==a?void 0:a.z)||0),d=new Ammo.btHingeConstraint(t.ammo,e.ammo,l,m,c,h,!0);return this.physicsWorld.addConstraint(d,o),d}slider(t,e,s={},o=!0){const i=this.getTransform(t.ammo,e.ammo),{frameA:r={},frameB:n={},linearLowerLimit:a=0,linearUpperLimit:l=0,angularLowerLimit:m=0,angularUpperLimit:c=0}=s,h=i.transformA.getRotation();h.setEulerZYX(r.x||0,r.y||0,r.z||0),i.transformA.setRotation(h);const d=i.transformB.getRotation();d.setEulerZYX(n.x||0,n.y||0,n.z||0),i.transformB.setRotation(d);const u=new Ammo.btSliderConstraint(t.ammo,e.ammo,i.transformA,i.transformB,!0);return u.setLowerLinLimit(a),u.setUpperLinLimit(l),u.setLowerAngLimit(m),u.setUpperAngLimit(c),this.physicsWorld.addConstraint(u,o),u}spring(t,e,s={},o=!0){const{stiffness:i=50,damping:r=.01,angularLock:n=!1,linearLowerLimit:a={},linearUpperLimit:l={},angularLowerLimit:m={},angularUpperLimit:c={},offset:h={},center:d=!1,enableSpring:u=!0}=s,p=Object.assign({x:0,y:0,z:0},h),y=this.getTransform(t.ammo,e.ammo,p,d),g=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,y.transformA,y.transformB,!0);this.tmpBtVector3.setValue(a.x||0,a.y||0,a.z||0),g.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(l.x||0,l.y||0,l.z||0),g.setLinearUpperLimit(this.tmpBtVector3),n?(this.tmpBtVector3.setValue(0,0,0),g.setAngularLowerLimit(this.tmpBtVector3),g.setAngularUpperLimit(this.tmpBtVector3)):(console.log(m,c),g.setAngularLowerLimit(this.toAmmoV3(m,-Math.PI)),g.setAngularUpperLimit(this.toAmmoV3(c,Math.PI)));for(let t=0;t<3;t++)g.enableSpring(t,u),g.setStiffness(t,i),g.setDamping(t,r);return this.physicsWorld.addConstraint(g,o),g}coneTwist(t,e,s,o=!0){const{frameA:i,frameB:r}=s,n=new Ammo.btTransform;n.setIdentity(),n.getOrigin().setValue((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),this.getTransform(t.ammo,e.ammo);const l=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,n,a);return l.setAngularOnly(!0),this.physicsWorld.addConstraint(l,o),l}dof(t,e,s={},o=!0){const{offset:i,center:r=!1}=s,n=Object.assign({x:0,y:0,z:0},i),a=this.getTransform(t.ammo,e.ammo,n,r),l=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,a.transformA,a.transformB,!0),{linearLowerLimit:m,linearUpperLimit:c,angularLowerLimit:h,angularUpperLimit:d}=s,u=this.toAmmoV3(m),p=this.toAmmoV3(c),y=this.toAmmoV3(h,-Math.PI),g=this.toAmmoV3(d,Math.PI);return l.setLinearLowerLimit(u),l.setLinearUpperLimit(p),l.setAngularLowerLimit(y),l.setAngularUpperLimit(g),Ammo.destroy(u),Ammo.destroy(p),Ammo.destroy(y),Ammo.destroy(g),this.physicsWorld.addConstraint(l,o),l}}var c=i(729);const h="hull",d="manual",u=function(){const t=new o.Vector3,e=new o.Vector3,s=new o.Matrix4;return function(o,i,r,n={}){if(n.type=h,b(n),n.fit===d)return console.warn("cannot use fit: manual with type: hull"),null;const a=x(o,i),l=new Ammo.btVector3,m=new Ammo.btConvexHullShape;m.setMargin(n.margin),e.addVectors(a.max,a.min).multiplyScalar(.5);let c=0;for(let t=0;t<o.length;t++)c+=o[t].length/3;const u=n.hullMaxVertices||1e5;c>u&&console.warn(`too many vertices for hull shape; sampling ~${u} from ~${c} vertices`);const p=Math.min(1,u/c);for(let r=0;r<o.length;r++){const n=o[r];s.fromArray(i[r]);for(let i=0;i<n.length;i+=3){const a=r===o.length-1&&i===n.length-3;(Math.random()<=p||a)&&(t.set(n[i],n[i+1],n[i+2]).applyMatrix4(s).sub(e),l.setValue(t.x,t.y,t.z),m.addPoint(l,a))}}let y=m;if(m.getNumVertices()>=100){const t=new Ammo.btShapeHull(m);t.buildHull(n.margin),Ammo.destroy(m),y=new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()),t.numVertices()),Ammo.destroy(t)}return Ammo.destroy(l),f(y,n,v(r,n)),y}}(),p=function(){const t=new o.Vector3,e=new o.Vector3,s=new o.Matrix4;return function(o,i,r,n,a={}){if(a.type="hacd",b(a),a.fit===d)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=x(o,i),m=v(n,a);let c=0,h=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<o.length;t++)c+=o[t].length/3,r&&r[t]?h+=r[t].length/3:h+=o[t].length/9;const u=new Ammo.HACD;a.hasOwnProperty("compacityWeight")&&u.SetCompacityWeight(a.compacityWeight),a.hasOwnProperty("volumeWeight")&&u.SetVolumeWeight(a.volumeWeight),a.hasOwnProperty("nClusters")&&u.SetNClusters(a.nClusters),a.hasOwnProperty("nVerticesPerCH")&&u.SetNVerticesPerCH(a.nVerticesPerCH),a.hasOwnProperty("concavity")&&u.SetConcavity(a.concavity);const p=Ammo._malloc(3*c*8),y=Ammo._malloc(3*h*4);u.SetPoints(p),u.SetTriangles(y),u.SetNPoints(c),u.SetNTriangles(h);let g=p/8,w=y/4;for(let n=0;n<o.length;n++){const a=o[n];s.fromArray(i[n]);for(let o=0;o<a.length;o+=3)t.set(a[o+0],a[o+1],a[o+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[g+0]=t.x,Ammo.HEAPF64[g+1]=t.y,Ammo.HEAPF64[g+2]=t.z,g+=3;if(r[n]){const t=r[n];for(let e=0;e<t.length;e++)Ammo.HEAP32[w]=t[e],w++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[w]=t,w++}u.Compute(),Ammo._free(p),Ammo._free(y);const A=u.GetNClusters(),V=[];for(let t=0;t<A;t++){const e=new Ammo.btConvexHullShape;e.setMargin(a.margin);const s=u.GetNPointsCH(t),o=u.GetNTrianglesCH(t),i=Ammo._malloc(3*s*8),r=Ammo._malloc(3*o*4);u.GetCH(t,i,r);const n=i/8;for(let t=0;t<s;t++){const o=new Ammo.btVector3,i=Ammo.HEAPF64[n+3*t+0],r=Ammo.HEAPF64[n+3*t+1],a=Ammo.HEAPF64[n+3*t+2];o.setValue(i,r,a),e.addPoint(o,t===s-1),Ammo.destroy(o)}f(e,a,m),V.push(e)}return V}}(),y=function(){const t=new o.Vector3,e=new o.Vector3,s=new o.Matrix4;return function(o,i,r,n,a={}){if(a.type="vhacd",b(a),a.fit===d)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=x(o,i),m=v(n,a);let c=0,h=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<o.length;t++)c+=o[t].length/3,r&&r[t]?h+=r[t].length/3:h+=o[t].length/9;const u=new Ammo.VHACD,p=new Ammo.Parameters;a.hasOwnProperty("resolution")&&p.set_m_resolution(a.resolution),a.hasOwnProperty("depth")&&p.set_m_depth(a.depth),a.hasOwnProperty("concavity")&&p.set_m_concavity(a.concavity),a.hasOwnProperty("planeDownsampling")&&p.set_m_planeDownsampling(a.planeDownsampling),a.hasOwnProperty("convexhullDownsampling")&&p.set_m_convexhullDownsampling(a.convexhullDownsampling),a.hasOwnProperty("alpha")&&p.set_m_alpha(a.alpha),a.hasOwnProperty("beta")&&p.set_m_beta(a.beta),a.hasOwnProperty("gamma")&&p.set_m_gamma(a.gamma),a.hasOwnProperty("pca")&&p.set_m_pca(a.pca),a.hasOwnProperty("mode")&&p.set_m_mode(a.mode),a.hasOwnProperty("maxNumVerticesPerCH")&&p.set_m_maxNumVerticesPerCH(a.maxNumVerticesPerCH),a.hasOwnProperty("minVolumePerCH")&&p.set_m_minVolumePerCH(a.minVolumePerCH),a.hasOwnProperty("convexhullApproximation")&&p.set_m_convexhullApproximation(a.convexhullApproximation),a.hasOwnProperty("oclAcceleration")&&p.set_m_oclAcceleration(a.oclAcceleration);const y=Ammo._malloc(3*c*8+3),g=Ammo._malloc(3*h*4);let w=y/8,A=g/4;for(let n=0;n<o.length;n++){const a=o[n];s.fromArray(i[n]);for(let o=0;o<a.length;o+=3)t.set(a[o+0],a[o+1],a[o+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[w+0]=t.x,Ammo.HEAPF64[w+1]=t.y,Ammo.HEAPF64[w+2]=t.z,w+=3;if(r[n]){const t=r[n];for(let e=0;e<t.length;e++)Ammo.HEAP32[A]=t[e],A++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[A]=t,A++}u.Compute(y,3,c,g,3,h,p),Ammo._free(y),Ammo._free(g);const V=u.GetNConvexHulls(),C=[],_=new Ammo.ConvexHull;for(let t=0;t<V;t++){u.GetConvexHull(t,_);const e=_.get_m_nPoints(),s=(_.get_m_points(),new Ammo.btConvexHullShape);s.setMargin(a.margin);for(let t=0;t<e;t++){const o=new Ammo.btVector3,i=_.get_m_points(3*t+0),r=_.get_m_points(3*t+1),n=_.get_m_points(3*t+2);o.setValue(i,r,n),s.addPoint(o,t===e-1),Ammo.destroy(o)}f(s,a,m),C.push(s)}return Ammo.destroy(_),Ammo.destroy(u),C}}(),g=function(){const t=new o.Vector3,e=new o.Vector3,s=new o.Vector3,i=new o.Matrix4;return function(o,r,n,a,l={}){if(l.type="mesh",b(l),l.fit===d)return console.warn("cannot use fit: manual with type: mesh"),null;const m=v(a,l),c=new Ammo.btVector3,h=new Ammo.btVector3,u=new Ammo.btVector3,p=new Ammo.btTriangleMesh(!0,!1);for(let a=0;a<o.length;a++){const l=o[a],m=n[a]?n[a]:null;if(i.fromArray(r[a]),m)for(let o=0;o<m.length;o+=3){const r=3*m[o],n=3*m[o+1],a=3*m[o+2];t.set(l[r],l[r+1],l[r+2]).applyMatrix4(i),e.set(l[n],l[n+1],l[n+2]).applyMatrix4(i),s.set(l[a],l[a+1],l[a+2]).applyMatrix4(i),c.setValue(t.x,t.y,t.z),h.setValue(e.x,e.y,e.z),u.setValue(s.x,s.y,s.z),p.addTriangle(c,h,u,!1)}else for(let o=0;o<l.length;o+=9)t.set(l[o+0],l[o+1],l[o+2]).applyMatrix4(i),e.set(l[o+3],l[o+4],l[o+5]).applyMatrix4(i),s.set(l[o+6],l[o+7],l[o+8]).applyMatrix4(i),c.setValue(t.x,t.y,t.z),h.setValue(e.x,e.y,e.z),u.setValue(s.x,s.y,s.z),p.addTriangle(c,h,u,!1)}const y=new Ammo.btVector3(m.x,m.y,m.z);let g;return p.setScaling(y),Ammo.destroy(y),g=l.concave?new Ammo.btBvhTriangleMeshShape(p,!0,!0):new Ammo.btConvexTriangleMeshShape(p,!0),g.resources=[p],Ammo.destroy(c),Ammo.destroy(h),Ammo.destroy(u),f(g,l),g}}();function b(t){t.type=t.type||h,t.margin=t.hasOwnProperty("margin")?t.margin:.01}const f=function(t,e,s){},w=function(){const t=new o.Matrix4;return function(e,s,i){parseInt(o.REVISION)>=123?t.copy(e.matrixWorld).invert():t.getInverse(e.matrixWorld),(new o.Vector3).setFromMatrixScale(e.matrixWorld),e.traverse((r=>{const n=new o.Matrix4;r.isMesh&&(s.includeInvisible||r.el&&r.el.object3D.visible||r.visible)&&(r===e?n.identity():(r.updateWorldMatrix(!0),n.multiplyMatrices(t,r.matrixWorld)),i(r.geometry.isBufferGeometry?r.geometry.attributes.position.array:r.geometry.vertices,n.elements,r.geometry.index?r.geometry.index.array:null))}))}}(),v=function(){const t=new o.Matrix4;return function(e,s={}){const i=new o.Vector3(1,1,1);return"all"===s.fit&&(t.fromArray(e),i.setFromMatrixScale(t)),i}}(),x=(new o.Vector3,function(t,e){const s=new o.Box3;let i=1/0,r=1/0,n=1/0,a=-1/0,l=-1/0,m=-1/0;return s.min.set(0,0,0),s.max.set(0,0,0),A(t,e,(t=>{t.x<i&&(i=t.x),t.y<r&&(r=t.y),t.z<n&&(n=t.z),t.x>a&&(a=t.x),t.y>l&&(l=t.y),t.z>m&&(m=t.z)})),s.min.set(i,r,n),s.max.set(a,l,m),s}),A=function(){const t=new o.Vector3,e=new o.Matrix4;return function(s,o,i){for(let r=0;r<s.length;r++){e.fromArray(o[r]);for(let o=0;o<s[r].length;o+=3)t.set(s[r][o],s[r][o+1],s[r][o+2]).applyMatrix4(e),i(t)}}}(),V=class{constructor(){this._defaultMaterial=new o.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}};var C=function(t,e){var s={};for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&e.indexOf(o)<0&&(s[o]=t[o]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(o=Object.getOwnPropertySymbols(t);i<o.length;i++)e.indexOf(o[i])<0&&Object.prototype.propertyIsEnumerable.call(t,o[i])&&(s[o[i]]=t[o[i]])}return s};class _{constructor(t){this.scene=t,this.isHeadless="headless"===t,this.defaultMaterial=new V}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){"headless"!==this.scene&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,s){const{x:i=0,y:r=0,z:n=0}=s;let l;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":l=new o.Line(t,e);break;case"PointsMaterial":l=new o.Points(t,e);break;default:l=new a(t,e)}return l.position.set(i,r,n),l.castShadow=l.receiveShadow=!0,l}makeExtrude(t,e){const{x:s,y:i,z:r,name:n,shape:a,autoCenter:l=!0,breakable:m=!1}=t,c=C(t,["x","y","z","name","shape","autoCenter","breakable"]),{depth:h=1,bevelEnabled:d=!1}=c,u=new o.ExtrudeBufferGeometry(a,Object.assign({depth:h,bevelEnabled:d},c)),p=this.addMaterial(e),y=this.createMesh(u,p,{x:s,y:i,z:r});return l&&y.geometry.center(),y.name=n||`body_id_${y.id}`,y.shape="extrude",y}addExtrude(t,e={}){const s=this.makeExtrude(t,e);return this.addExisting(s),s}makePlane(t,e){const{x:s,y:i,z:r,name:n,breakable:a=!1}=t,l=C(t,["x","y","z","name","breakable"]),m=new o.PlaneBufferGeometry(l.width||1,l.height||1,l.widthSegments||1,l.heightSegments||1),c=this.addMaterial(e);c.side=o.DoubleSide;const h=this.createMesh(m,c,{x:s,y:i,z:r});return h.name=n||`body_id_${h.id}`,h.shape="plane",h}addPlane(t,e){const s=this.makePlane(t,e);return this.addExisting(s),s}makeSphere(t,e){const{x:s,y:i,z:r,name:n,breakable:a=!1}=t,l=C(t,["x","y","z","name","breakable"]),m=new o.SphereBufferGeometry(l.radius||1,l.widthSegments||16,l.heightSegments||12,l.phiStart||void 0,l.phiLength||void 0,l.thetaStart||void 0,l.thetaLength||void 0),c=this.addMaterial(e),h=this.createMesh(m,c,{x:s,y:i,z:r});return h.name=n||`body_id_${h.id}`,h.shape="sphere",h}addSphere(t={},e={}){const s=this.makeSphere(t,e);return this.addExisting(s),s}makeBox(t,e){const{x:s,y:i,z:r,name:n,breakable:a=!1}=t,l=C(t,["x","y","z","name","breakable"]),m=new o.BoxBufferGeometry(l.width||1,l.height||1,l.depth||1,l.widthSegments||void 0,l.heightSegments||void 0,l.depthSegments||void 0),c=this.addMaterial(e),h=this.createMesh(m,c,{x:s,y:i,z:r});return h.name=n||`body_id_${h.id}`,h.shape="box",h}addBox(t={},e={}){const s=this.makeBox(t,e);return this.addExisting(s),s}addGround(t,e={}){const s=this.makeBox(t,e);return s.rotateX(o.MathUtils.degToRad(90)),this.addExisting(s),s}makeCylinder(t={},e={}){const{x:s,y:i,z:r,name:n,breakable:a=!1}=t,l=C(t,["x","y","z","name","breakable"]),m=new o.CylinderBufferGeometry(l.radiusTop||1,l.radiusBottom||1,l.height||1,l.radiusSegments||void 0,l.heightSegments||void 0,l.openEnded||void 0,l.thetaStart||void 0,l.thetaLength||void 0),c=this.addMaterial(e),h=this.createMesh(m,c,{x:s,y:i,z:r});return h.name=n||`body_id_${h.id}`,h.shape="cylinder",h}addCylinder(t={},e={}){const s=this.makeCylinder(t,e);return this.addExisting(s),s}makeCone(t={},e={}){const{x:s,y:i,z:r,name:n,breakable:a=!1}=t,l=C(t,["x","y","z","name","breakable"]),m=new o.ConeBufferGeometry(l.radius||1,l.height||1,l.radiusSegments||8,l.heightSegments||1,l.openEnded||!1,l.thetaStart||0,l.thetaLength||2*Math.PI),c=this.addMaterial(e),h=this.createMesh(m,c,{x:s,y:i,z:r});return h.name=n||`body_id_${h.id}`,h.shape="cone",h}addCone(t={},e={}){const s=this.makeCone(t,e);return this.addExisting(s),s}makeTorus(t={},e={}){const{x:s,y:i,z:r,name:n,breakable:a=!1}=t,l=C(t,["x","y","z","name","breakable"]),m=new o.TorusBufferGeometry(l.radius||void 0,l.tube||void 0,l.radialSegments||void 0,l.tubularSegments||void 0,l.arc||void 0),c=this.addMaterial(e),h=this.createMesh(m,c,{x:s,y:i,z:r});return h.name=n||`body_id_${h.id}`,h.shape="torus",h}addTorus(t={},e={}){const s=this.makeTorus(t,e);return this.addExisting(s),s}addMaterial(t={}){const s=Object.keys(t)[0];let i;if("headless"===this.scene)return this.defaultMaterial.get();switch(s){case"basic":i=new o.MeshBasicMaterial(t.basic);break;case"normal":i=new o.MeshNormalMaterial(t.normal);break;case"standard":i=new o.MeshStandardMaterial(t.standard);break;case"lambert":i=new o.MeshLambertMaterial(t.lambert);break;case"phong":i=new o.MeshPhongMaterial(t.phong);break;case"physical":void 0!==t.physical?i=new o.MeshPhysicalMaterial(t.physical):(e("You need to pass parameters to the physical material. (Fallback to default material)"),i=this.defaultMaterial.get());break;case"toon":i=new o.MeshToonMaterial(t.toon);break;case"line":i=new o.LineBasicMaterial(t.line);break;case"points":i=new o.PointsMaterial(t.points);break;case"custom":i=t.custom||this.defaultMaterial.get();break;default:i=this.defaultMaterial.get()}return i}}class B extends c.EventEmitter{addCollider(t,e,s){t.body&&e.body&&(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",(o=>{var i,r;const{bodies:n,event:a}=o;(null===(i=n[0])||void 0===i?void 0:i.name)&&(null===(r=n[1])||void 0===r?void 0:r.name)&&(null==t?void 0:t.name)&&(null==e?void 0:e.name)&&(n[0].name===t.name&&n[1].name===e.name||n[1].name===t.name&&n[0].name===e.name)&&s(a)})))}}var M=i(152);const P=t=>new(window.THREE&&window.THREE.ConvexGeometry?window.THREE.ConvexGeometry:M.ConvexGeometry)(t),T=function(t,e){this.minSizeForBreak=t||1.4,this.smallDelta=e||1e-4,this.tempLine1=new o.Line3,this.tempPlane1=new o.Plane,this.tempPlane2=new o.Plane,this.tempPlane_Cut=new o.Plane,this.tempCM1=new o.Vector3,this.tempCM2=new o.Vector3,this.tempVector3=new o.Vector3,this.tempVector3_2=new o.Vector3,this.tempVector3_3=new o.Vector3,this.tempVector3_P0=new o.Vector3,this.tempVector3_P1=new o.Vector3,this.tempVector3_P2=new o.Vector3,this.tempVector3_N0=new o.Vector3,this.tempVector3_N1=new o.Vector3,this.tempVector3_AB=new o.Vector3,this.tempVector3_CB=new o.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var s=0;s<900;s++)this.segments[s]=!1};var S;T.prototype={constructor:T,prepareBreakableObject:function(t,e,s,o,i){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),t.userData.ammoPhysicsData={};var r=t.userData.ammoPhysicsData;r.mass=e,r.velocity=s.clone(),r.angularVelocity=o.clone(),r.breakable=i},subdivideByImpact:function(t,e,s,o,i){var r=[],n=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(e,s),n.setFromCoplanarPoints(e,t.position,this.tempVector3);var l=i+o,m=this;return function i(c,h,d,u){if(Math.random()<.05*u||u>l)r.push(c);else{var p=Math.PI;0===u?(a.normal.copy(n.normal),a.constant=n.constant):u<=o?(p=(d-h)*(.2+.6*Math.random())+h,m.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(s,p).add(e),a.setFromCoplanarPoints(e,m.tempVector3,m.tempVector3_2)):(p=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,m.tempVector3_2.copy(e).sub(c.position).applyAxisAngle(s,p).add(c.position),m.tempVector3_3.copy(s).add(c.position),a.setFromCoplanarPoints(c.position,m.tempVector3_3,m.tempVector3_2)),m.cutByPlane(c,a,m.tempResultObjects);var y=m.tempResultObjects.object1,g=m.tempResultObjects.object2;y&&i(y,h,p,u+1),g&&i(g,p,d,u+1)}}(t,0,2*Math.PI,0),r},cutByPlane:function(t,s,i){var r=t.geometry,n=r.attributes.position.array,a=r.attributes.normal.array,l=n.length/3,m=l/3,c=r.getIndex();function h(t,e){var s=3*t+e;return c?c[s]:s}c&&(m=(c=c.array).length/3);for(var d=[],u=[],p=this.smallDelta,y=l*l,g=0;g<y;g++)this.segments[g]=!1;var b=this.tempVector3_P0,f=this.tempVector3_P1,w=this.tempVector3_N0,v=this.tempVector3_N1;for(g=0;g<m-1;g++){var x=h(g,0),A=h(g,1),V=h(g,2);w.set(a[x],a[x]+1,a[x]+2);for(var C=g+1;C<m;C++){var _=h(C,0),B=h(C,1),M=h(C,2);v.set(a[_],a[_]+1,a[_]+2),1-w.dot(v)<p&&(x===_||x===B||x===M?A===_||A===B||A===M?(this.segments[x*l+A]=!0,this.segments[A*l+x]=!0):(this.segments[V*l+x]=!0,this.segments[x*l+V]=!0):A!==_&&A!==B&&A!==M||(this.segments[V*l+A]=!0,this.segments[A*l+V]=!0))}}var S=this.tempPlane_Cut;for(t.updateMatrix(),T.transformPlaneToLocalSpace(s,t.matrix,S),g=0;g<m;g++)for(var O=h(g,0),k=h(g,1),E=h(g,2),z=0;z<3;z++){var D=0===z?O:1===z?k:E,j=0===z?k:1===z?E:O;if(!this.segments[D*l+j]){this.segments[D*l+j]=!0,this.segments[j*l+D]=!0,b.set(n[3*D],n[3*D+1],n[3*D+2]),f.set(n[3*j],n[3*j+1],n[3*j+2]);var L=0;(R=S.distanceToPoint(b))>p?(L=2,u.push(b.clone())):R<-p?(L=1,d.push(b.clone())):(L=3,d.push(b.clone()),u.push(b.clone()));var R,W=0;if((R=S.distanceToPoint(f))>p?(W=2,u.push(f.clone())):R<-p?(W=1,d.push(f.clone())):(W=3,d.push(f.clone()),u.push(f.clone())),1===L&&2===W||2===L&&1===W){this.tempLine1.start.copy(b),this.tempLine1.end.copy(f);var F=new o.Vector3;if(void 0===(F=S.intersectLine(this.tempLine1,F)))return console.error("Internal error: segment does not intersect plane."),i.segmentedObject1=null,i.segmentedObject2=null,0;d.push(F),u.push(F.clone())}}}var H=.5*t.userData.ammoPhysicsData.mass;this.tempCM1.set(0,0,0);var I=0,U=d.length;if(U>0){for(g=0;g<U;g++)this.tempCM1.add(d[g]);for(this.tempCM1.divideScalar(U),g=0;g<U;g++)(Q=d[g]).sub(this.tempCM1),I=Math.max(I,Q.x,Q.y,Q.z);this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);var G=0,N=u.length;if(N>0){for(g=0;g<N;g++)this.tempCM2.add(u[g]);for(this.tempCM2.divideScalar(N),g=0;g<N;g++){var Q;(Q=u[g]).sub(this.tempCM2),G=Math.max(G,Q.x,Q.y,Q.z)}this.tempCM2.add(t.position)}var q=null,$=null,X=0;if(U>4)try{(q=new o.Mesh(P(d),t.material)).position.copy(this.tempCM1),q.quaternion.copy(t.quaternion),q.userData=t.userData,this.prepareBreakableObject(q,H,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*I>this.minSizeForBreak),X++}catch(t){e("Error in ConvexObjectBreaker.ts"),e(t)}if(N>4)try{($=new o.Mesh(P(u),t.material)).position.copy(this.tempCM2),$.quaternion.copy(t.quaternion),$.userData=t.userData,this.prepareBreakableObject($,H,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*G>this.minSizeForBreak),X++}catch(t){e("Error in ConvexObjectBreaker.ts"),e(t)}return i.object1=q,i.object2=$,X}},T.transformFreeVector=function(t,e){var s=t.x,o=t.y,i=t.z,r=e.elements;return t.x=r[0]*s+r[4]*o+r[8]*i,t.y=r[1]*s+r[5]*o+r[9]*i,t.z=r[2]*s+r[6]*o+r[10]*i,t},T.transformFreeVectorInverse=function(t,e){var s=t.x,o=t.y,i=t.z,r=e.elements;return t.x=r[0]*s+r[1]*o+r[2]*i,t.y=r[4]*s+r[5]*o+r[6]*i,t.z=r[8]*s+r[9]*o+r[10]*i,t},T.transformTiedVectorInverse=function(t,e){var s=t.x,o=t.y,i=t.z,r=e.elements;return t.x=r[0]*s+r[1]*o+r[2]*i-r[12],t.y=r[4]*s+r[5]*o+r[6]*i-r[13],t.z=r[8]*s+r[9]*o+r[10]*i-r[14],t},T.transformPlaneToLocalSpace=(S=new o.Vector3,function(t,e,s){s.normal.copy(t.normal),s.constant=t.constant;var o=T.transformTiedVectorInverse(t.coplanarPoint(S),e);T.transformFreeVectorInverse(s.normal,e),s.constant=-o.dot(s.normal)});const O=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const t=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){}return!1})(),k=(t,e)=>{((t,e)=>{var s=document.createElement("script");s.onload=()=>{e()},s.onerror=()=>{throw new Error("failed to load "+t)},s.async=!0,s.src=t,document.head.appendChild(s)})(O?`${t}/ammo.wasm.js`:`${t}/ammo.js`,(()=>e()))},E=(t,e)=>{"undefined"!=typeof window&&(window.__loadPhysics=!0),k(t,(()=>{Ammo().then((()=>{e()}))}))},z=(t,e)=>{e.forEach((e=>{Object.getOwnPropertyNames(e.prototype).forEach((s=>{Object.defineProperty(t.prototype,s,Object.getOwnPropertyDescriptor(e.prototype,s))}))}))};class D{constructor(t){this.physics=t}setRayFromWorld(t=0,e=0,s=0){this._btRayFrom.setValue(t,e,s)}setRayToWorld(t=0,e=0,s=0){this._btRayTo.setValue(t,e,s)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback),this._btRayCallback="closest"===this.type?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){void 0!==this._btRayFrom&&Ammo.destroy(this._btRayFrom),void 0!==this._btRayTo&&Ammo.destroy(this._btRayTo),void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback)}}class j{constructor(t){this.physics=t,this.type="closest",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}class L{constructor(t){this.physics=t,this.type="allHits",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}z(j,[D,class{constructor(t){this.physics=t}getHitPointWorld(){const t=this._btRayCallback.get_m_hitPointWorld();return{x:t.x(),y:t.y(),z:t.z()}}getHitNormalWorld(){const t=this._btRayCallback.get_m_hitNormalWorld();return{x:t.x(),y:t.y(),z:t.z()}}getCollisionObject(){return Ammo.castObject(this._btRayCallback.get_m_collisionObject(),Ammo.btRigidBody).threeObject}}]),z(L,[D,class{constructor(t){this.physics=t}getHitPointsWorld(){const t=this._btRayCallback.get_m_hitPointWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const o=t.at(s);e.push({x:o.x(),y:o.y(),z:o.z()})}return e}getHitPointWorld(){return console.warn("[enable3d] Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const t=this._btRayCallback.get_m_hitNormalWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const o=t.at(s);e.push({x:o.x(),y:o.y(),z:o.z()})}return e}getCollisionObjects(){const t=[],e=this._btRayCallback.get_m_collisionObjects();for(let s=e.size()-1;s>=0;s--){const o=Ammo.castObject(e.at(s),Ammo.btRigidBody);t.push(o.threeObject)}return t}}]);class R{constructor(t=!0){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}class W extends c.EventEmitter{constructor(t,e={}){super(),this.scene=t,this.config=e,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless="headless"===t,this.tmpEuler=new o.Euler,this.tmpQuaternion=new o.Quaternion,this.tmpVector3=new o.Vector3,this.tmpVector3a=new o.Vector3,this.tmpMatrix4=new o.Matrix4,this.tmpMatrix4a=new o.Matrix4,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new o.Vector3,this.impactPoint=new o.Vector3,this.impactNormal=new o.Vector3,"headless"!==t&&(this.defaultMaterial=new V),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var e;const s=Object.keys(t).includes("body")?t.body:t;if(void 0===(null==s?void 0:s.ammo))return;const o=s.ammo.name;let i=s.ammo.threeObject;if(o&&i&&(null===(e=null==i?void 0:i.body)||void 0===e?void 0:e.ammo)){i.body.isSoftBody?this.physicsWorld.removeSoftBody(i.body.ammo):this.physicsWorld.removeRigidBody(i.body.ammo),i.body.destructor(),i.body=void 0,i.hasBody=!1,delete s.ammo.threeObject;for(let t=0;t<this.rigidBodies.length;t++)this.rigidBodies[t].name===o&&(this.rigidBodies.splice(t,1),t--)}"headless"===this.scene&&i&&(i=null)}setup(){if(this.worldTransform=new Ammo.btTransform,"function"==typeof this.config.setupPhysicsWorld?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),"headless"!==this.scene){this.convexBreaker=new T,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new B,this.factory=new _(this.scene),this.shapes=new class{constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const s=this.factory.add.plane(t,e);return this.addExisting(s,t),s}addSphere(t={},e={}){const s=this.factory.add.sphere(t,e);return this.addExisting(s,t),s}addBox(t={},e={}){const s=this.factory.add.box(t,e);return this.addExisting(s,t),s}addGround(t,e={}){const s=this.factory.add.ground(t,e),o=Object.assign(Object.assign({},t),{mass:0,collisionFlags:1});return this.addExisting(s,o),s}addCylinder(t={},e={}){const s=this.factory.add.cylinder(t,e);return this.addExisting(s,t),s}addCone(t={},e={}){const s=this.factory.add.cone(t,e);return this.addExisting(s,t),s}addTorus(t={},e={}){const s=this.factory.add.torus(t,e);return this.addExisting(s,t),s}addExtrude(t,e={}){const s=this.factory.add.extrude(t,e);return s.translateX(1),this.addExisting(s),s}}(this.factory,((t,e)=>this.addExisting(t,e))),this.constraints=new m(this.worldTransform,this.physicsWorld),"headless"!==this.scene&&(this.debugDrawer=new class{constructor(t,e,s={}){this.scene=t,this.world=e,this.options=s,this.debugDrawMode=s.debugDrawMode||1;const i=32768&this.debugDrawMode||!1,r=s.maxBufferSize||1e6;this.geometry=new o.BufferGeometry;const n=new Float32Array(3*r),a=new Float32Array(3*r);this.geometry.setAttribute("position",new o.BufferAttribute(n,3).setUsage(o.StaticDrawUsage)),this.geometry.setAttribute("color",new o.BufferAttribute(a,3).setUsage(o.StaticDrawUsage)),this.index=0;const l=new o.LineBasicMaterial({vertexColors:!0,depthTest:!i});this.mesh=new o.LineSegments(this.geometry,l),i&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,s){const o=Ammo.HEAPF32,i=o[(s+0)/4],r=o[(s+4)/4],n=o[(s+8)/4],a=o[(t+0)/4],l=o[(t+4)/4],m=o[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,a,l,m),this.geometry.attributes.color.setXYZ(this.index++,i,r,n);const c=o[(e+0)/4],h=o[(e+4)/4],d=o[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,c,h,d),this.geometry.attributes.color.setXYZ(this.index++,i,r,n)}drawContactPoint(t,e,s,o,i){const r=Ammo.HEAPF32,n=r[(i+0)/4],a=r[(i+4)/4],l=r[(i+8)/4],m=r[(t+0)/4],c=r[(t+4)/4],h=r[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,m,c,h),this.geometry.attributes.color.setXYZ(this.index++,n,a,l);const d=r[(e+0)/4]*s,u=r[(e+4)/4]*s,p=r[(e+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,m+d,c+u,h+p),this.geometry.attributes.color.setXYZ(this.index++,n,a,l)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}}(this.scene,this.physicsWorld,{}))}updateDebugger(){"headless"!==this.scene&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:e=!1}=this.config;let s;if(!e){const t=new Ammo.btDefaultCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),o=new Ammo.btDbvtBroadphase,i=new Ammo.btSequentialImpulseConstraintSolver;s=new Ammo.btDiscreteDynamicsWorld(e,o,i,t)}if(e){const t=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),o=new Ammo.btDbvtBroadphase,i=new Ammo.btSequentialImpulseConstraintSolver,r=new Ammo.btDefaultSoftBodySolver;s=new Ammo.btSoftRigidDynamicsWorld(e,o,i,t,r)}return s.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),s}createDebrisFromBreakableObject(t,e){"headless"!==this.scene&&(t.material=e.material,t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,this.scene.add(t),this.addExisting(t),t.body.fractureImpulse=e.body.fractureImpulse,t.body.breakable=!1,setTimeout((()=>{t.body.breakable=!0}),2500))}removeDebris(t){"headless"!==this.scene&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const e=t/1e3;this.physicsWorld.stepSimulation(e,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let t=0;t<this.rigidBodies.length;t++){const e=this.rigidBodies[t],s=e.body.ammo.getMotionState();if(s)if(s.getWorldTransform(this.worldTransform),e.body.didUpdate&&(e.body._emitUpdateEvents&&e.body.eventEmitter.emit("update"),e.body.didUpdate=!1),e.body.ammo.isKinematicObject()&&e.body.needUpdate)e.getWorldQuaternion(this.tmpQuaternion),e.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),s.setWorldTransform(this.worldTransform),e.body.needUpdate=!1;else if(e.body.skipUpdate);else if(!e.body.ammo.isStaticObject()){let t=this.worldTransform.getOrigin(),s=this.worldTransform.getRotation(),i=e.body.offset;if(e.body.ignoreScale)this.tmpVector3a.set(e.scale.x,e.scale.y,e.scale.z);else{const t=e.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(t.x(),t.y(),t.z())}this.tmpVector3.set(t.x()+i.x,t.y()+i.y,t.z()+i.z),this.tmpQuaternion.set(s.x(),s.y(),s.z(),s.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),e.parent?parseInt(o.REVISION)>=123?this.tmpMatrix4a.copy(e.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(e.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(e.position,e.quaternion,e.scale)}}}detectCollisions(){var t,e;const s=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const o=this.physicsWorld.getDispatcher(),i=o.getNumManifolds();for(let r=0;r<i;r++){let i=o.getManifoldByIndexInternal(r),n=i.getNumContacts();const a=Ammo.castObject(i.getBody0(),Ammo.btRigidBody),l=Ammo.castObject(i.getBody1(),Ammo.btRigidBody);let m=a.threeObject,c=l.threeObject;if(!m||!c)continue;if(""===a.name&&""===l.name)continue;const h=null===(t=m.body)||void 0===t?void 0:t.checkCollisions,d=null===(e=c.body)||void 0===e?void 0:e.checkCollisions,u=m.body.breakable,p=c.body.breakable,y=m.body.fractureImpulse,g=c.body.fractureImpulse,b=u||p;if(!h&&!d&&!b)continue;let f=!1,w=0,v="start";for(let t=0;t<n;t++){const e=i.getContactPoint(t);if(e.getDistance()<=0){f=!0;const t=e.getAppliedImpulse(),o=e.get_m_positionWorldOnB(),i=e.get_m_normalWorldOnB();if(h||d){const t=[m.name,c.name].sort(),e=`${t[0]}__${t[1]}`;this.earlierDetectedCollisions.find((t=>t.combinedName===e))&&(v="collision"),s.find((t=>t.combinedName===e))||(s.push({combinedName:e,collision:!0}),this.collisionEvents.emit("collision",{bodies:[m,c],event:v}))}t>=w&&(w=t,(u||p)&&(this.impactPoint.set(o.x(),o.y(),o.z()),this.impactNormal.set(i.x(),i.y(),i.z())));break}}if(!f)continue;if(!b)continue;const x=2;if(this.emptyV3.set(0,0,0),m.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:u,physicsBody:a},c.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:p,physicsBody:l},u&&w>y&&m.fragmentDepth<x){const t=this.convexBreaker.subdivideByImpact(m,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=a.getLinearVelocity(),o=a.getAngularVelocity(),i=t[s];i.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),i.userData.ammoPhysicsData.angularVelocity.set(o.x(),o.y(),o.z()),this.createDebrisFromBreakableObject(i,m)}this.objectsToRemove[this.numObjectsToRemove++]=m}if(p&&w>g&&c.fragmentDepth<x){const t=this.convexBreaker.subdivideByImpact(c,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=l.getLinearVelocity(),o=l.getAngularVelocity(),i=t[s];i.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),i.userData.ammoPhysicsData.angularVelocity.set(o.x(),o.y(),o.z()),this.createDebrisFromBreakableObject(i,c)}this.objectsToRemove[this.numObjectsToRemove++]=c}}for(let t=0;t<this.numObjectsToRemove;t++)this.removeDebris(this.objectsToRemove[t]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach((t=>{const{combinedName:e}=t;if(!s.find((t=>t.combinedName===e))){const t=e.split("__"),s=this.rigidBodies.find((e=>e.name===t[0])),o=this.rigidBodies.find((e=>e.name===t[1])),i="end";s&&o&&this.collisionEvents.emit("collision",{bodies:[s,o],event:i})}})),this.earlierDetectedCollisions=[...s]}setGravity(t=0,e=-9.8,s=0){this.tmpBtVector3.setValue(t,e,s),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){"undefined"!=typeof Ammo?"function"==typeof Ammo?Ammo().then((()=>{this.setup()})):this.setup():e("Are you sure you included ammo.js?")}get add(){return{collider:(t,e,s)=>this.collisionEvents.addCollider(t,e,s),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>"closest"===t?new j(this):new L(this)}}prepareThreeObjectForCollisionShape(t,s={}){var o,i;const{autoCenter:r=!1}=s,n={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let a="unknown";const l=(null===(o=t.geometry)||void 0===o?void 0:o.type)||"unknown";/box/i.test(l)?a="box":/cone/i.test(l)?a="cone":/cylinder/i.test(l)?a="cylinder":/extrude/i.test(l)?a="extrude":/plane/i.test(l)?a="plane":/sphere/i.test(l)?a="sphere":/torus/i.test(l)&&(a="torus");let m=Object.assign(Object.assign({},n),null===(i=null==t?void 0:t.geometry)||void 0===i?void 0:i.parameters);return s.shape?(m=Object.assign(Object.assign({},n),s),a=s.shape):t.shape&&(a=t.shape),Object.keys(m).forEach((t=>{void 0===m[t]&&n[t]&&(m[t]=n[t])})),r&&t.geometry.center(),"cylinder"===a&&(m.radius=s.radius||m.radiusTop),"extrude"===a&&(a="hacd"),"mesh"!==a&&"convex"!==a||(a="convexMesh"),"concave"===a&&(a="concaveMesh"),"unknown"===a&&(e(`Shape for ${null==t?void 0:t.name} not recognized! Will fallback to box.`),a="box"),{shape:a,params:m,object:t}}createCollisionShape(t,e,s){const i=(null==s?void 0:s.quaternion)?null==s?void 0:s.quaternion:new o.Quaternion(0,0,0,1),{axis:r="y"}=e,n=new Ammo.btVector3,a=null==s?void 0:s.geometry;s&&(null==a?void 0:a.isGeometry)&&(s.geometry=(new o.BufferGeometry).fromGeometry(a));let l,m={};switch(-1!==this.complexShapes.indexOf(t)&&(m=(t=>{const e=(new o.Matrix4).elements,s=[],i=[],r=[];return w(t,{},((t,e,o)=>{s.push(t),i.push(e),r.push(o)})),{vertices:s,matrices:i,indexes:r,matrixWorld:e}})(s)),t){case"box":n.setValue(e.width/2,e.height/2,e.depth/2),l=new Ammo.btBoxShape(n);break;case"sphere":l=new Ammo.btSphereShape(e.radius);break;case"cylinder":switch(r){case"y":n.setValue(e.radius,e.height/2,e.radius),l=new Ammo.btCylinderShape(n);break;case"x":n.setValue(e.height/2,e.radius,e.radius),l=new Ammo.btCylinderShapeX(n);break;case"z":n.setValue(e.radius,e.radius,e.height/2),l=new Ammo.btCylinderShapeZ(n)}break;case"cone":switch(r){case"y":l=new Ammo.btConeShape(e.radius,e.height);break;case"x":l=new Ammo.btConeShapeX(e.radius,e.height);break;case"z":l=new Ammo.btConeShapeZ(e.radius,e.height)}break;case"capsule":switch(r){case"y":l=new Ammo.btCapsuleShape(e.radius,e.height);break;case"x":l=new Ammo.btCapsuleShapeX(e.radius,e.height);break;case"z":l=new Ammo.btCapsuleShapeZ(e.radius,e.height)}break;case"torus":l=((t,e)=>{const{radius:s=1,tube:o=.4,tubularSegments:i=8}=t,r=Math.PI,n=i,a=Math.sqrt(2*o*o-2*o*o*Math.cos(2*r/n)),l=new Ammo.btVector3(o,r/n+.5*a,o),m=new Ammo.btCylinderShape(l);m.setMargin(.05);const c=new Ammo.btCompoundShape,h=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,s,0),u=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let t=0;t<n;t++){const e=2*t*r/n,s=d.rotate(h,e),o=new Ammo.btTransform;u.setRotation(h,e+Math.PI/2),o.setIdentity(),o.setOrigin(s),o.setRotation(u),c.addChildShape(o,m)}return c})(e,i);break;case"plane":l=g(m.vertices,m.matrices,m.indexes,m.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"hull":l=u(m.vertices,m.matrices,m.matrixWorld,e);break;case"hacd":l=p(m.vertices,m.matrices,m.indexes,m.matrixWorld,e);break;case"vhacd":l=y(m.vertices,m.matrices,m.indexes,m.matrixWorld,e);break;case"convexMesh":l=g(m.vertices,m.matrices,m.indexes,m.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"concaveMesh":l=g(m.vertices,m.matrices,m.indexes,m.matrixWorld,Object.assign(Object.assign({},e),{concave:!0}))}Ammo.destroy(n);const{x:c,y:h,z:d}=e;return(c||h||d)&&(l.offset={x:c||0,y:h||0,z:d||0}),Array.isArray(l)&&(l=this.mergeCollisionShapesToCompoundShape(l)),l}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach((t=>{const{offset:s}=t,o=new Ammo.btTransform;o.setIdentity(),s&&o.getOrigin().setValue(s.x||0,s.y||0,s.z||0),e.addChildShape(o,t)})),e}addExisting(t,e={}){const{hasBody:s}=t;if(s)return void console.warn(`[Enable3d]: Object "${t.name}" already has a physical body!`);const i=new o.Vector3,r=new o.Quaternion,n=new o.Vector3;t.getWorldPosition(i),t.getWorldQuaternion(r),t.getWorldScale(n);const a="1"===(e.collisionFlags||0).toString(2).slice(-1),l="1"===(e.collisionFlags||0).toString(2).slice(-2,-1),{shape:m="unknown",compound:c=[],mass:h=(a||l?0:1),collisionFlags:d=0,collisionGroup:u=1,collisionMask:p=-1,offset:y,breakable:g=!1,addChildren:b=!0,margin:f=.01,ignoreScale:w=!1,fractureImpulse:v=1}=e;if(w&&n.set(1,1,1),c.length>=1){const e=c.map((t=>this.createCollisionShape(t.shape,t))),s=this.mergeCollisionShapesToCompoundShape(e),o=this.finishCollisionShape(s,i,r,n,f),a=this.collisionShapeToRigidBody(s,o,h,l);return this.addRigidBodyToWorld(t,a,d,u,p,y),t.body.breakable=g,t.body.fractureImpulse=v,void(t.body.ignoreScale=w)}const x=[];if("unknown"!==m||t.isMesh){const s=this.prepareThreeObjectForCollisionShape(t,e),o=this.createCollisionShape(s.shape,s.params,s.object);x.push(o)}if("unknown"===m&&b&&t.children.length>=1&&t.children.forEach((t=>{if(t.isMesh){const e=this.prepareThreeObjectForCollisionShape(t),s=this.createCollisionShape(e.shape,e.params,e.object);s.offset=t.position.clone(),x.push(s)}})),0===x.length){const s=this.prepareThreeObjectForCollisionShape(t,e),o=this.createCollisionShape(s.shape,s.params,s.object);x.push(o)}const A=1===x.length?x[0]:this.mergeCollisionShapesToCompoundShape(x),V=this.finishCollisionShape(A,i,r,n,f),C=this.collisionShapeToRigidBody(A,V,h,l);this.addRigidBodyToWorld(t,C,d,u,p,y),t.body.breakable=g,t.body.fractureImpulse=v,t.body.ignoreScale=w}addRigidBodyToWorld(t,e,i,r,n,a){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(e,r,n);const l=Object.values(e)[0];e.name=t.name,t.body=new class{constructor(t,e){this.physics=t,this.ammo=e,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.breakable=!1,this.fractureImpulse=1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new o.Euler,this.tmpQuaternion=new o.Quaternion,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new s.EventEmitter,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){void 0===this.eventEmitter&&(this.eventEmitter=new s.EventEmitter)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",(()=>{t()})):this.eventEmitter.on("update",(()=>{t()}))}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",(e=>{const{bodies:s,event:o}=e;s[0].name===this.name?t(s[1],o):s[1].name===this.name&&t(s[0],o)}))}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,s){const o=this.tmpEuler.set(t,e,s),i=this.tmpQuaternion.set(0,0,0,1);i.setFromEuler(o),this.tmpBtQuaternion.setValue(0,0,0,1);const r=this.tmpBtQuaternion;r.setValue(i.x,i.y,i.z,i.w),this.physics.worldTransform.setRotation(r)}get rotation(){let t,e,s;const o=this.physics.worldTransform.getRotation();let i=this.tmpQuaternion.set(o.x(),o.y(),o.z(),o.w());i.w>1&&(i=i.normalize());const r=2*Math.acos(i.w),n=Math.sqrt(1-i.w*i.w);return n<.001?(t=i.x,e=i.y,s=i.z):(t=i.x/n,e=i.y/n,s=i.z/n),{x:t*r,y:e*r,z:s*r}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(t,e,s){this.physics.worldTransform.getOrigin().setValue(t,e,s)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setDamping(t,e){this.ammo.setDamping(t,e)}setGravity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}}(this,e),t.hasBody=!0,t.ptr=l,e.threeObject=t,a&&(t.body.offset=Object.assign({x:0,y:0,z:0},a)),t.body.setCollisionFlags(i)}finishCollisionShape(t,e,s,o,i){t.setMargin(i);const r=new Ammo.btQuaternion(0,0,0,1);r.setValue(s.x,s.y,s.z,s.w);const n=new Ammo.btTransform;n.setIdentity(),n.getOrigin().setValue(e.x,e.y,e.z),n.setRotation(r),Ammo.destroy(r);const a=new Ammo.btVector3(o.x,o.y,o.z);return t.setLocalScaling(a),Ammo.destroy(a),n}collisionShapeToRigidBody(t,e,s,o){const i=new Ammo.btDefaultMotionState(e),r=new Ammo.btVector3(0,0,0);s>0&&t.calculateLocalInertia(s,r);const n=new Ammo.btRigidBodyConstructionInfo(s,i,t,r),a=new Ammo.btRigidBody(n);return(s>0||o)&&a.setActivationState(4),a}}})(),r})()}));
//# sourceMappingURL=enable3d.ammoPhysics.0.22.0-dev.1.min.js.map